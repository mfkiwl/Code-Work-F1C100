# 实验九

## 一. 实验目的

1. 了解 FAT 文件系统原理。
2. 了解 MicroSD 卡的原理与控制方式。
3. 学习 TM4C129x Series Cortex-M4 的同步串口 QSSI 操作方式。
4. 学习 QSSI 相关库函数的使用。

## 二. 实验内容

使用cmdline方式与sd卡进行交互,实现类似bash的效果.

## 三. 实验流程

```flow
st=>start: 开始
op1=>operation: 时钟初始化
op2=>operation: SSI初始化
op3=>operation: 液晶初始化
op4=>operation: UART初始化
op5=>operation: 接收UART命令
op6=>operation: 处理命令
cond=>condition: nStatus是否为0?
op7=>operation: 正常运行程序,输出结果
op8=>operation: 输出相应错误提示

st->op1->op2->op3->op4->op5->op6->cond
cond(yes)->op7->op5
cond(no)->op8->op5

```

## 四. 实验代码

```c
//sd 初始化
void SD_Init()
{
	FPUEnable();
  	FPULazyStackingEnable();
	ROM_SysTickPeriodSet(SysCtlClockGet()/ 300);
	ROM_SysTickEnable();
	SysTickIntRegister(SysTickIntHandler);
	ROM_SysTickIntEnable();
	ROM_IntMasterEnable();
}

//sd 测试代码
int SD_Test()
{
	int nStatus;
 	FRESULT fresult;
	
	char s[20];
	
	TFT_ShowString(0,15*n++,"SD Card Example Program",WHITE,BLACK);
	TFT_ShowString(0,15*n++,"Type \'help\' for help.",WHITE,BLACK);
	fresult = f_mount(0, &g_sFatFs);
	if(fresult != FR_OK)
	{
			UARTprintf("f_mount error: %s\n", StringFromFresult(fresult));
			return(1);
	}

	while(1)
	{

			sprintf(s,"%s", g_cCwdBuf);
			TFT_ShowString(0,15*n++,s,WHITE,BLACK);
			//
			// Get a line of text from the user.
			//
			UARTgets(g_cCmdBuf, sizeof(g_cCmdBuf));

			//
			// Pass the line from the user to the command processor.  It will be
			// parsed and valid commands executed.
			//
			nStatus = CmdLineProcess(g_cCmdBuf);

			//
			// Handle the case of bad command.
			//
			if(nStatus == CMDLINE_BAD_CMD)
			{
					UARTprintf("Bad command!\n");
			}

			//
			// Handle the case of too many arguments.
			//
			else if(nStatus == CMDLINE_TOO_MANY_ARGS)
			{
					UARTprintf("Too many arguments for command processor!\n");
			}

			//
			// Otherwise the command was executed.  Print the error code if one was
			// returned.
			//
			else if(nStatus != 0)
			{
					UARTprintf("Command returned error code %s\n",
											StringFromFresult((FRESULT)nStatus));
			}
	}
}
```

## 实验效果

![1574130974224](%E5%AE%9E%E9%AA%8C%E4%B9%9D.assets/1574130974224.png)



# 实验十  TFT液晶显示实验

## 一. 实验目的

1. 了解 240x400TFT LCD 的工作原理。
2. 了解 TFT LCD 控制芯片 OTM4001A 的控制方式。
3. 学习并使用数学库 IQmathLib.h。
4. 学习 TM4C129x Series Cortex-M4 的 EPI 总线操作方式。
5. 学习 EPI 相关库函数的使用。

## 二. 实验内容

使用液晶屏,显示各种基本图形,点,线,矩形,圆以及汉字.

## 三. 实验流程

```flow
st=>start: 开始
op1=>operation: 时钟初始化
op2=>operation: EPI初始化
op3=>operation: 液晶初始化
op4=>operation: UART初始化
op5=>operation: 显示字符
ed=>end: 结束
st->op1->op2->op3->op4->op5->ed
```



## 四. 实验代码

```c
//液晶初始化
void
TFT_Init()
{

    EPIGPIOinit();
    uint32_t ui32ClockMS;

    uint32_t ui32SysClockSpeed = ui32SysClock;

    ui32ClockMS = ui32SysClockSpeed / (3 * 1000);

    SysCtlPeripheralEnable(LCD_RS_PERIPH);
    SysCtlPeripheralEnable(LCD_RD_PERIPH);
    SysCtlPeripheralEnable(LCD_WR_PERIPH);
    SysCtlPeripheralEnable(LCD_CS_PERIPH);
    SysCtlPeripheralEnable(LCD_RESET_PERIPH);
    SysCtlPeripheralEnable(LCD_IM0_PERIPH);

    InitGPIOLCDInterface(ui32ClockMS);

    HWREG(LCD_RESET_PIN_REG) = 0xFF;
    SysCtlDelay(200000);   //Under 120MHz system clock, SysCtlDelay(1000) is about 25us, SysCtlDelay(1) for about 25ns.
    HWREG(LCD_RESET_PIN_REG) = 0;
    SysCtlDelay(400000);
    HWREG(LCD_RESET_PIN_REG) = 0xFF;
    SysCtlDelay(4000000);
    // sleep
    //    TFTLCD_EnterSleep();
    //======== Power ON sequence============//
    WriteCommand(0x0606);
    WriteData(0x0000);//Set the order of receiving data when using i80 interface.1st to 2nd
    SysCtlDelay(4000000);
    WriteCommand(0x0007);
    WriteData(0x0001);//Display Control 1
    SysCtlDelay(200000);
    WriteCommand(0x0110);
    WriteData(0x0001);
    SysCtlDelay(200000);
    WriteCommand(0x0100);
    WriteData(0x17B0);
    WriteCommand(0x0101);
    WriteData(0x0147);
    WriteCommand(0x0102);
    WriteData(0x019D);
    WriteCommand(0x0103);
    WriteData(0x3600);
    WriteCommand(0x0281);
    WriteData(0x0010);
    SysCtlDelay(200000);
    WriteCommand(0x0102);
    WriteData(0x01BD);
    SysCtlDelay(200000);
//==========================================//
    WriteCommand(0x0000);
    WriteData(0x0000);
    WriteCommand(0x0001);
    WriteData(0x0100);

    WriteCommand(0x0002);
    WriteData(0x0100);
    WriteCommand(0x0003);
    WriteData(0x00A0);

    WriteCommand(0x0006);
    WriteData(0x0000);
    WriteCommand(0x0008);
    WriteData(0x0202);//Display Control 2

    WriteCommand(0x0009);
    WriteData(0x0001);//Display Control 3
    WriteCommand(0x000B);
    WriteData(0x0000);//Sam test

    WriteCommand(0x000C);
    WriteData(0x0000);//External Display Interface Control 1
    //RM = 0,System interface/VSYNC interface
    WriteCommand(0x000F);
    WriteData(0x0000);//External Display Interface Control 2
    WriteCommand(0x0007);
    WriteData(0x0001);

    //Panel Interface Control 1
    WriteCommand(0x0010);
    WriteData(0x0013);//Set the clock cycle per line  19

    WriteCommand(0x0011);
    WriteData(0x0202);// NOWI [2:0]: Set the adjacent gate driver output non-overlap

    WriteCommand(0x0012);
    WriteData(0x0300);
    WriteCommand(0x0020);
    WriteData(0x021E);
    WriteCommand(0x0021);
    WriteData(0x0202);

    WriteCommand(0x0022);
    WriteData(0x0100);
    WriteCommand(0x0090);
    WriteData(0x8000);//Set the position of the frame marker. 0 < FMP < BP + NL + FP
    WriteCommand(0x0092);
    WriteData(0x8000);
    WriteCommand(0x0100);
    WriteData(0x16B0);
    SysCtlDelay(200000);
    WriteCommand(0x0101);
    WriteData(0x0147);
    WriteCommand(0x0102);
    WriteData(0x01BE);
    SysCtlDelay(200000);
    WriteCommand(0x0103);
    WriteData(0x1600);
    SysCtlDelay(200000);
    WriteCommand(0x0107);
    WriteData(0x0000);
    SysCtlDelay(200000);
    WriteCommand(0x0110);
    WriteData(0x0001);
    SysCtlDelay(200000);
    WriteCommand(0x0210);
    WriteData(0x0000);
    WriteCommand(0x0211);
    WriteData(0x00EF);
    WriteCommand(0x0212);
    WriteData(0x0000);
    WriteCommand(0x0213);
    WriteData(0x018F);
    WriteCommand(0x0200);
    WriteData(0x0000);//tb

    WriteCommand(0x0201);
    WriteData(0x0000);//tb
    WriteCommand(0x0280);
    WriteData(0x0000);
    WriteCommand(0x0281);
    WriteData(0x0007);

    WriteCommand(0x0282);
    WriteData(0x0000);
    SysCtlDelay(200000);
    WriteCommand(0x0300);
    WriteData(0x0002);
    WriteCommand(0x0301);
    WriteData(0x081D);
    WriteCommand(0x0302);
    WriteData(0x1621);
    WriteCommand(0x0303);
    WriteData(0x3D12);
    WriteCommand(0x0304);
    WriteData(0x3C0B);
    WriteCommand(0x0305);
    WriteData(0x1004);
    WriteCommand(0x0306);
    WriteData(0x0A06);
    WriteCommand(0x0307);
    WriteData(0x0612);
    WriteCommand(0x0308);
    WriteData(0x0105);
    WriteCommand(0x0309);
    WriteData(0x0004);
    WriteCommand(0x030A);
    WriteData(0x0F05);
    WriteCommand(0x030B);
    WriteData(0x0F00);
    WriteCommand(0x030C);
    WriteData(0x000F);
    WriteCommand(0x030D);
    WriteData(0x050F);
    WriteCommand(0x030E);
    WriteData(0x0106);
    WriteCommand(0x030F);
    WriteData(0x0406);

    WriteCommand(0x0400);
    WriteData(0x3500);
    WriteCommand(0x0401);
    WriteData(0x0001);
    WriteCommand(0x0404);
    WriteData(0x0000);
    WriteCommand(0x0500);
    WriteData(0x0000);
    WriteCommand(0x0501);
    WriteData(0x0000);
    WriteCommand(0x0502);
    WriteData(0x0000);
    WriteCommand(0x0503);
    WriteData(0x0000);
    WriteCommand(0x0504);
    WriteData(0x0000);
    WriteCommand(0x0505);
    WriteData(0x0000);
    WriteCommand(0x0600);
    WriteData(0x0000);
    WriteCommand(0x0606);
    WriteData(0x0000);
    WriteCommand(0x06F0);
    WriteData(0x0000);
    WriteCommand(0x07F0);
    WriteData(0x5420);

    WriteCommand(0x07F2);
    WriteData(0x00DF);
    WriteCommand(0x07F3);
    WriteData(0x288A);
    WriteCommand(0x07F4);
    WriteData(0x0022);
    WriteCommand(0x07F5);
    WriteData(0x0041);
    WriteCommand(0x07F0);
    WriteData(0x0000);
    WriteCommand(0x0007);
    WriteData(0x0173);
    SysCtlDelay(200000);
    WriteCommand(0x0007);
    WriteData(0x0061);
    SysCtlDelay(200000);
    WriteCommand(0x0007);
    WriteData(0x0173);
    SysCtlDelay(2000000);
    WriteCommand(0x0202);


    TFT_CLEAR(0);
    IntMasterEnable();
    SysTickPeriodSet(ui32SysClock / TICKS_PER_SECOND);
    SysTickIntRegister(SysTickHandler);
    SysTickIntEnable();
    SysTickEnable();

    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_0);
    GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0, GPIO_PIN_0);
}

//================================================================================================
//	实现功能：	画一条水平线
//	输入参数：	x0:横坐标起点,x1:横坐标终点,y:纵坐标,color:指定颜色
//================================================================================================
void TFT_DrawHorizontalLine(uint32_t x0, uint32_t x1, uint32_t y, uint32_t color)
{
    uint32_t i = 0, PointNum = 0;
    PointNum = x1 - x0;
    for(i = 0; i < PointNum; i++)
    {
        TFT_DrawPoint(x0 + i, y, color);
    }

}


//================================================================================================
//	实现功能：	画一条垂直线
//	输入参数：	y0:纵坐标起点,y1:纵坐标终点,x:横坐标,color:指定颜色
//================================================================================================
void TFT_DrawVerticalLine(uint32_t y0, uint32_t y1, uint32_t x, uint32_t color)
{
    uint32_t i = 0, PointNum = 0;
    PointNum = y1 - y0;
    for(i = 0; i < PointNum; i++)
    {
        TFT_DrawPoint(x, y0 + i, color);
    }

}

//显示一条直线
void TFT_DrawLine(uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, uint32_t color)
{
    int dx, dy, e;
    dx = x2 - x1;
    dy = y2 - y1;
    if (dx >= 0)
    {
        if (dy >= 0) // dy>=0
        {
            if (dx >= dy) // 1/8 octant
            {
                e = dy - dx / 2;
                while (x1 <= x2)
                {
                    TFT_DrawPoint(x1, y1, color);
                    if (e > 0)
                    {
                        y1 += 1;
                        e -= dx;
                    }
                    x1 += 1;
                    e += dy;
                }
            }
            else // 2/8 octant
            {
                e = dx - dy / 2;
                while (y1 <= y2)
                {
                    TFT_DrawPoint(x1, y1, color);
                    if (e > 0)
                    {
                        x1 += 1;
                        e -= dy;
                    }
                    y1 += 1;
                    e += dx;
                }
            }
        }
        else // dy<0
        {
            dy = -dy;     // dy=abs(dy)
            if (dx >= dy) // 8/8 octant
            {
                e = dy - dx / 2;
                while (x1 <= x2)
                {
                    TFT_DrawPoint(x1, y1, color);
                    if (e > 0)
                    {
                        y1 -= 1;
                        e -= dx;
                    }
                    x1 += 1;
                    e += dy;
                }
            }
            else // 7/8 octant
            {
                e = dx - dy / 2;
                while (y1 >= y2)
                {
                    TFT_DrawPoint(x1, y1, color);
                    if (e > 0)
                    {
                        x1 += 1;
                        e -= dy;
                    }
                    y1 -= 1;
                    e += dx;
                }
            }
        }
    }
    else //dx<0
    {
        dx = -dx;    //dx=abs(dx)
        if (dy >= 0) // dy>=0
        {
            if (dx >= dy) // 4/8 octant
            {
                e = dy - dx / 2;
                while (x1 >= x2)
                {
                    TFT_DrawPoint(x1, y1, color);
                    if (e > 0)
                    {
                        y1 += 1;
                        e -= dx;
                    }
                    x1 -= 1;
                    e += dy;
                }
            }
            else // 3/8 octant
            {
                e = dx - dy / 2;
                while (y1 <= y2)
                {
                    TFT_DrawPoint(x1, y1, color);
                    if (e > 0)
                    {
                        x1 -= 1;
                        e -= dy;
                    }
                    y1 += 1;
                    e += dx;
                }
            }
        }
        else // dy<0
        {
            dy = -dy;     // dy=abs(dy)
            if (dx >= dy) // 5/8 octant
            {
                e = dy - dx / 2;
                while (x1 >= x2)
                {
                    TFT_DrawPoint(x1, y1, color);
                    if (e > 0)
                    {
                        y1 -= 1;
                        e -= dx;
                    }
                    x1 -= 1;
                    e += dy;
                }
            }
            else // 6/8 octant
            {
                e = dx - dy / 2;
                while (y1 >= y2)
                {
                    TFT_DrawPoint(x1, y1, color);
                    if (e > 0)
                    {
                        x1 -= 1;
                        e -= dy;
                    }
                    y1 -= 1;
                    e += dx;
                }
            }
        }
    }
}

void TFT_DrawCircle(uint32_t x, uint32_t y, uint8_t radius, uint32_t color)
{
    int a, b, num;
    a = 0;
    b = radius;
    while(2 * b * b >= radius * radius)
    {
        TFT_DrawPoint(x + a, y - b, color);
        TFT_DrawPoint(x - a, y - b, color);
        TFT_DrawPoint(x - a, y + b, color);
        TFT_DrawPoint(x + a, y + b, color);

        TFT_DrawPoint(x + b, y + a, color);
        TFT_DrawPoint(x + b, y - a, color);
        TFT_DrawPoint(x - b, y - a, color);
        TFT_DrawPoint(x - b, y + a, color);

        a++;
        num = (a * a + b * b) - radius * radius;
        if(num > 0)
        {
            b--;
            a--;
        }
    }
}


//显示长方形
void TFT_DrawRectangle(uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t color)
{
    TFT_DrawLine(x, y, x + width, y, color);
    TFT_DrawLine(x + width, y, x + width, y + height, color);
    TFT_DrawLine(x + width, y + height, x, y + height, color);
    TFT_DrawLine(x, y + height, x, y, color);
}


void TFT_ShowByte(uint8_t x, uint8_t y, uint8_t  byte, uint32_t color)
{
    for(int i = 0; i < 8; i++)
    {
        if(byte & (0x80 >> i))
            TFT_DrawPoint(x + i, y, color);
    }
}
//显示汉字
void TFT_ShowName(uint8_t x, uint8_t y, uint8_t  name, uint32_t color)
{
    for(int i = 0; i < 4; i++)
    {
        uint8_t * temp = jch[4 * name + i];
        for(int j = 0; j < 8; j++)
        {
            TFT_ShowByte(x, y + 8 * i + j, temp[2 * j], color);
            TFT_ShowByte(x + 8, y + 8 * i + j, temp[2 * j + 1], color);
        }
    }
}

//测试函数
void TFT_Test()
{
    uint16_t ui32Loop = 0, ulItemCount = 0, FinishCalculateFlag = 0, ulLastTickCount = 0;
    float fElapsedTime;
    _iq24 fRadians, fSine;

    FPUEnable();
    FPULazyStackingEnable();

    SysTickPeriodSet(ui32SysClock / TICKS_PER_SECOND);
    IntMasterEnable();
    SysTickIntRegister(SysTickHandler);
    SysTickIntEnable();
    SysTickEnable();

    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_0);
    GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0, GPIO_PIN_0);

    TFT_ShowName(10, 10, 0, WHITE);
    TFT_ShowName(28, 10, 1, WHITE);
    TFT_ShowName(46, 10, 2, WHITE);
    while(1)
    {
        for(int i = 1; i < 6; i++)
        {
            TFT_DrawCircle(120, 200, i * 20, BLUE);
            TFT_DrawRectangle(20, 30, 50, 100, WHITE);
            SysCtlDelay(ui32SysClock / 2);
        }
        TFT_CLEAR(0);
    }

    TFT_ShowString(50, 10, "GC211 TFTLCD test!", CYAN, LIGHTBLUE);
    TFT_ShowString(60, 40, "y=sin(pi*t/2)", GREEN, BLACK);
    TFT_DrawHorizontalLine(0, 240, 63, GREEN);
    TFT_DrawHorizontalLine(0, 240, 128, GREEN);
    TFT_DrawHorizontalLine(0, 240, 193, GREEN);
    TFT_DrawVerticalLine(64, 193, 0, GREEN);
    TFT_DrawVerticalLine(64, 193, 239, GREEN);
    TFT_ShowString(12, 46, "1", WHITE, BLACK);
    TFT_ShowString(2, 195, "-1", WHITE, BLACK);

    while(1)
    {
        while(ulLastTickCount == g_ulTickCount)
        {
        }
        ulLastTickCount = g_ulTickCount;

        if(ulItemCount == SERIES_LENGTH)
        {
            FinishCalculateFlag = 1;
        }
        else
        {

            g_cSeries[ulItemCount].xAxis = ++ulItemCount;
        }

        fElapsedTime = (float)g_ulTickCount * FSECONDS_PER_TICK;
        fRadians = _IQ24(fElapsedTime * (float)M_PI);     

        fRadians = _IQdiv2(fRadians);        

        fSine = _IQ24sin(fRadians);        

        g_cSeries[ulItemCount - 1].data = _IQ24mpyI32int(fSine, 64); 

        if(!FinishCalculateFlag)
        {
            TFT_DrawPoint(g_cSeries[ulItemCount - 1].xAxis, 
                          g_cSeries[ulItemCount - 1].data + 128, BLUE);
        }
        else
        {
            for(ui32Loop = 2; ui32Loop < SERIES_LENGTH; ui32Loop++)
            {
                
                TFT_DrawPoint(g_cSeries[ui32Loop - 1].xAxis,
                              g_cSeries[ui32Loop - 1].data + 128, 0);
                g_cSeries[ui32Loop - 1].data = g_cSeries[ui32Loop].data;
                TFT_DrawPoint(g_cSeries[ui32Loop - 1].xAxis,
                              g_cSeries[ui32Loop - 1].data + 128, BLUE);
            }

            TFT_DrawHorizontalLine(0, 240, 128, GREEN);
            TFT_DrawVerticalLine(64, 192, 0, GREEN);
            TFT_DrawVerticalLine(64, 192, 239, GREEN);
        }


    }
}

```

## 五. 实验现象



![QQ图片20191119182316](%E5%AE%9E%E9%AA%8C%E4%B9%9D.assets/QQ%E5%9B%BE%E7%89%8720191119182316.jpg)


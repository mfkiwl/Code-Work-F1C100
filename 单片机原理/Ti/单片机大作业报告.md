# **单片机大作业报告**

## 实验平台

本次大作业采用TI公司的ek-tm4c1294xl LaunchPad.

* 开发板简介

  * 描述

     Tiva™ C 系列 TM4C1294 连接 LaunchPad 评估板是用于基于 ARM® Cortex-M4 的微控制器的低成本评估平台。此连接 LaunchPad 设计重点突出了 [TM4C1294NCPDT](http://www.ti.com/product/tm4c1294ncpdt) 微控制器及其片上 10/100 以太网 MAC 和 PHY、USB 2.0、休眠模块、运动控制脉宽调制以及大量同步串行连接。 

  * 特性

    - TM4C1294NCPDT MCU：120MHz 32 位 ARM Cortex-M4 CPU，具有浮点、1MB 闪存、256KB SRAM、6KB EEPROM、集成式 10/100 以太网 MAC+PHY、数据保护硬件、8 个 32 位计时器、两个 12 位 2MSPS ADC、运动控制 PWM、USB H/D/O 以及大量其他串行通信接口
    - 两个可堆叠 BoosterPack XL 连接站点
    - 基于云的 Exosite 快速入门应用
    - TivaWare 2.1
    - 板载内电路调试接口 (ICDI)
    - 多重开发工具链支持：CCS、Keil、IAR、Mentor 和 GCC

  * 外观

     ![1575937149674](%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A.assets/1575937149674.png)
     
  * 片上资源

  ![1575420791590](C:%5CUsers%5CChenhui%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575420791590.png)

  ![1575420884647](C:%5CUsers%5CChenhui%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575420884647.png)

  

  * 拓展板资源

      * 数码管
      * 三轴加速计
      * LCD液晶屏
      * 4线电阻屏
      * 4*4矩阵键盘
      * 温度传感器
      * 无源蜂鸣器
      * 红外接收器
      * 8个LED流水灯
      * SD卡槽


## 实验目标

想尽可能的利用片上外设,以多任务的形式,使得各个外设同时工作.于是我移植了FreeRTOS.
>FreeRTOS是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满足较小系统的需要。 

我准备创建并运行下列任务

* LED任务

* 重力感应小球任务

* SD卡轮播图片任务

* MP3控制任务

* ADC采集任务

* 蜂鸣器任务

* 数码管任务

## 硬件设计

![1576557985674](%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A.assets/1576557985674.png)

为了方便板外外设的使用,我将使用到的模块集成在了一块小拓展板上,可以直接插在实验板上,免去了每次接线的麻烦.该拓展板上集成了NFC模块,OLED模块,MP3模块.使用了两个串口,一个硬件I2C.

<img src="%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A.assets/IMG20191210103332.jpg" alt="IMG20191210103332" style="zoom:50%;" />

<img src="%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A.assets/IMG20191210103338.jpg" alt="IMG20191210103338" style="zoom:50%;" />




## 软件设计

* 系统总览

![1575943437322](%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A.assets/1575943437322.png)

* 硬件初始化

  使用到的函数是BSP_Init()

  该函数主要完成了对系统时钟,各个外设的初始化,

  上电之后会等待用户刷卡,刷卡之后蜂鸣器会滴一声,然后显示开机图.

  在硬件初始化结束的时候,会调用FreeRTOS_Init()函数来初始化系统,然后开启总中断(如果在系统启动之前开启中断可能会影响系统正常启动)

* freeRTOS初始化

  使用到的函数是FreeRTOS_Init()

  该函数主要完成了对操作系统的初始化.

  创建了一些信号量,事件组以及软件定时器.创建了各个任务,最后启动任务调度
  
* 中断
	课程所提供的红外示例代码误码率很高,无法实用,于是用定时器中断加外部输入中断重新写了一个红外驱动.能达到极高的准确率和实时性.
	
	* 定时器中断
		
		由于红外解码对时间精度要求较高,于是启动了定时器中断,为红外解码提供时间基准
		每100us触发一次中断,每次计数值加一.
	
	* 红外引脚外部中断
当红外接收头接收到信号时,会从高电平变成低电平,所以配置了下降沿中断,中断中把每个信号持续时间记录下来,一次信号记录完之后会发送一个信号量,通知解码进程开始对结果进行判断.
    
      > 信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被[并发](https://baike.baidu.com/item/并发/11024806)调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。为了完成这个过程，需要创建一个信号量VI，然后将Acquire Semaphore VI以及Release Semaphore VI分别放置在每个关键代码段的首末端。确认这些信号量VI引用的是初始创建的信号量。 


* LED流水灯

  实现流水灯效果,轮流点亮八个LED灯,间隔100ms.

* 重力感应小球任务

  循环读取当前的x轴重力加速度和y轴重力加速度,在小球的基础坐标上加上xy轴的位移.显示在屏幕右上1/4,使用了卡尔曼滤波,使读取的数据又快又稳定.

* SD卡轮播图片任务

  循环读取并显示SD卡中的图像,并显示在屏幕的左上1/4.每隔5秒换一张.

* MP3控制任务

  MP3模块是使用串口控制的,控制方式比较多,可以触屏,可以红外,也可以通过齿轮(控制音量).

  在核心控制进程中,使用事件标志组的方式,来进行控制.

  > 事件标志组的实现是指各个任务之间使用事件标志组实现任务的通信或者同步机制。 

  控制进程会等待,直到有标志位触发,触屏进程中会轮询获得当前触摸点的坐标,然后进行坐标判断,如果判断为有按键被按下,则对应事件标志位置位,核心控制进程由标志位知道哪个按键被按下,可以做出对应的行为.比如播放暂停.这里我对触摸做了优化,在实例代码中,采样次数只有5次,稳定性太差,于是我把采样次数改为1000次,并使用了卡尔曼滤波,在保证响应速度的同时,准确度也能有保证.除了触摸按键控制,还可以使用红外遥控器进行控制.红外控制有两部分组成,一部分是中断部分,一部分是轮询部分,中断部分在前面已经说明了,会把红外信号的数据存在一个全局数组中.轮询部分创建了一个线程,对这个全局数组进行解码,如果解码正确则置对应标志位.控制进程接到置位可以做出对应行为,和触摸按键控制一样.


* ADC采集任务

  这部分使用了片内ADC,读取拓展板上的温度传感器和齿轮电阻上的电压值.ADC读取到的数据经过卡尔曼滤波,收敛很快,很稳定.读取到的温度值会显示在OLED屏幕上,读取到的电压值换算为MP3的音量值,范围为(0~30),当音量值发生改变时,就发送一条命令,控制MP3模块的音量,可以通过转动齿轮来控制MP3的音量.

* 蜂鸣器任务
  为了提供控制反馈,在控制进程接收到置位时,会发送一个信号量,蜂鸣器线程收到信号量时,会发出一声蜂鸣.

* 数码管任务

  使用硬件I2C与数码管进行通讯,轮流显示'1','2','3','4',间隔为一秒.

## 实验效果

见演示视频



## 主要代码

```c
//BSP初始化
void BSP_Init()
{

    SysClock = SysCtlClockFreqSet((SYSCTL_XTAL_25MHZ |
                                   SYSCTL_OSC_MAIN   | 
                                   SYSCTL_USE_PLL    | 
                                   SYSCTL_CFG_VCO_480),
                                   SysClockFreq);

    FPUEnable();
    FPULazyStackingEnable();

    TFT_Init();
    BUZZER_Init();
    USART0_Init();
    PN532_Init();

    while (uid != 0xEA04E2CF)
    {
        uid = PN532_Readuid();
        SysCtlDelay(100 * SysClock / 3000);
    }
    
    BUZZER_Beep();
    Show_BMP(0, 0, "logo.bmp");
    USART6_Init();
    PLAYER_Init();

    I2C0GPIOBEnable();
    ACCELERATOR_Init();
    ADC0_Init();
    TOUCH_Init();
    LED_Init();
    PCA9557_Init();
    OLED_Init();
    INFRARED_Init();
    TimerIntInitial();
    SysCtlDelay(3 * SysClock / 3);
    TFT_CLEAR(0);
    FreeRTOS_Init();
    IntMasterEnable();
}

//实现流水灯效果
static void LEDTask(void *pvParameters)
{
    while (1)
    {
        int i = 0, t = 0;
        for (;;)
        {
            i++;
            if (i > 8)
            {
                i = 1;
            }
            LED_Open(i);
            vTaskDelay(100);
            LED_Close(i);
        }
    }
}

//bmp轮播
static void BMPDisplay(void *pvParameters)
{
    uint8_t index = 0;
    char s[5];

    while (1)
    {
        sprintf(s, "%d.bmp", index++);
        taskENTER_CRITICAL();
        Show_BMP(0, 0, s);
        taskEXIT_CRITICAL();
        vTaskDelay(5000);
        if (index == 6)
            index = 0;
    }
}

//红外控制
static void INFRARED(void *pvParameters)
{
    uint8_t res;
    while (1)
    {
        xSemaphoreTake(InfraredReceive_Handle, portMAX_DELAY);
        receiveComplete = 0;
        res = Ir_Server();

        switch (res)
        {
        case irKEY1:
            xEventGroupSetBits(Command_Handle, KEY1_EVENT);
            break;
        case irKEY2:
            xEventGroupSetBits(Command_Handle, KEY2_EVENT);
            break;
        case irKEY3:
            xEventGroupSetBits(Command_Handle, KEY3_EVENT);
            break;
        case irKEY4:
            xEventGroupSetBits(Command_Handle, KEY4_EVENT);
            break;
        case irKEY5:
            xEventGroupSetBits(Command_Handle, KEY5_EVENT);
            break;
        default:
            break;
        }
    }
}

//触摸控制
static void GETPoint(void *pvParameters)
{
    TFT_ShowWheel();
    Get_Point();
}

//命令响应
static void Command_Control(void *pvParameters)
{
    EventBits_t r_event;
    while (1)
    {
        r_event = xEventGroupWaitBits(Command_Handle, 
                                      KEY1_EVENT | 
                                      KEY2_EVENT | 
                                      KEY3_EVENT | 
                                      KEY4_EVENT | 
                                      KEY5_EVENT, 
                                      pdTRUE, 
                                      pdFALSE, 
                                      portMAX_DELAY);
        
        xSemaphoreGive(BUZZER_Handle);
        switch (r_event)
        {
        case KEY1_EVENT: //previous
            PREVIOUS();
            break;
        case KEY2_EVENT: //next
            NEXT();
            break;
        case KEY3_EVENT: //play/pause
            PLAY_OR_PAUSE();
            break;
        case KEY4_EVENT: //add_volume
            ADD_VOLUME();
            break;
        case KEY5_EVENT: //sub_volume
            SUB_VOLUME();
            break;
        default:
            break;
        }
    }
}

//SD时钟控制
static void SDTicket(void *pvParameters)
{
    disk_timerproc();
}

//重力小球
static void GravityBall(void *parameter)
{
    int ball_x = 0;
    int ball_y = 0;

    int Gx = 0;
    int Gy = 0;

    KFP KFP_X = {0.02, 0, 0, 0, 0.001, 0.643};
    KFP KFP_Y = {0.02, 0, 0, 0, 0.001, 0.643};

    while (1)
    {
        taskENTER_CRITICAL();
        TFT_DrawRectangle(180 + 2 * ball_y / 10,
                          100 + 2 * ball_x / 10, 10, 10, BLACK);
        taskEXIT_CRITICAL();
        Gx = ACCELERATOR_Read('X');
        Gy = ACCELERATOR_Read('Y');

        ball_x = kalmanFilter(&KFP_X, (float)Gx);
        ball_y = kalmanFilter(&KFP_Y, (float)Gy);
        taskENTER_CRITICAL();
        TFT_DrawRectangle(180 + 2 * ball_y / 10, 
                          100 + 2 * ball_x / 10, 10, 10, RED);
        taskEXIT_CRITICAL();
        vTaskDelay(20);
    }
}

//ADC读取
static void ADCRead(void *parameter)
{
    uint16_t adc_value;

    char s[10];

    float v, t;
    float K_V, K_T;
    KFP KFP_T = {0.02, 0, 0, 0, 0.001, 0.543};
    KFP KFP_V = {0.02, 0, 0, 0, 0.001, 0.543};
    while (1)
    {
        for (int i = 0; i < 10; i++)
        {
            adc_value = ADC0_Read(0);
            t = (1.8663 - ((adc_value / 4096.0) * 3.3)) * 1000 / 11.69;
            adc_value = ADC0_Read(4);
            v = adc_value / 4096.0 * 3.3 * 1000;
            K_T = kalmanFilter(&KFP_T, t);
            K_V = kalmanFilter(&KFP_V, v);
        }
        taskENTER_CRITICAL();
        OLED_ShowStr(5, 1, "T:", 2);
        num2char(s, K_T, 2, 2);
        OLED_ShowStr(25, 1, s, 2);
        OLED_ShowStr(5, 4, "V:", 2);
        num2char(s, K_V, 4, 2);
        OLED_ShowStr(25, 4, s, 2);
        taskEXIT_CRITICAL();

        vTaskDelay(100);
    }
}

//蜂鸣器
static void BEEZZERBeep(void *parameter)
{
    while (1)
    {
        xSemaphoreTake(BUZZER_Handle, portMAX_DELAY);
        for (int i = 0; i < 100; i++)
        {
            BUZZER_Open();
            SysCtlDelay(180 * SysClock / 30000);
            BUZZER_Close();
            SysCtlDelay(180 * SysClock / 30000);
        }
    }
}

//数码管
static void DIGITALTube(void *parameter)
{
    while (1)
    {
        setnumber(1, '1');
        vTaskDelay(1000);
        setnumber(2, '2');
        vTaskDelay(1000);
        setnumber(3, '3');
        vTaskDelay(1000);
        setnumber(4, '4');
        vTaskDelay(1000);
    }
}

//FreeRTOS初始化
void FreeRTOS_Init()
{
    taskENTER_CRITICAL();
    InfraredReceive_Handle = xSemaphoreCreateBinary();
    BUZZER_Handle = xSemaphoreCreateBinary();
    Command_Handle = xEventGroupCreate();
    Swtmr1_Handle = xTimerCreate((const char *)"SDTicket",
                                 (TickType_t)10, 
                                 (UBaseType_t)pdTRUE,
                                 (void *)1, 
                                 (TimerCallbackFunction_t)SDTicket);
    xTimerStart(Swtmr1_Handle, 0);

    xTaskCreate(LEDTask, (const portCHAR *)"Led", 128, NULL,
                tskIDLE_PRIORITY + 10, NULL);
    xTaskCreate(GravityBall, (const portCHAR *)"Ball", 128, NULL,
                tskIDLE_PRIORITY + 10, NULL);
    xTaskCreate(GETPoint, (const portCHAR *)"Touch", 128, NULL,
                tskIDLE_PRIORITY + 10, NULL);
    xTaskCreate(INFRARED, (const portCHAR *)"Infrared", 128, NULL,
                tskIDLE_PRIORITY + 10, NULL);
    xTaskCreate(Command_Control, (const portCHAR *)"Control", 128, NULL,
                tskIDLE_PRIORITY + 10, NULL);
    xTaskCreate(BMPDisplay, (const portCHAR *)"BmpDisplay", 128, NULL,
                tskIDLE_PRIORITY + 10, NULL);
    xTaskCreate(ADCRead, (const portCHAR *)"ADC", 128, NULL,
                tskIDLE_PRIORITY + 10, NULL);
    xTaskCreate(BEEZZERBeep, (const portCHAR *)"Buzzer", 128, NULL,
                tskIDLE_PRIORITY + 10, NULL);
    xTaskCreate(DIGITALTube, (const portCHAR *)"DigitalTube", 128, NULL,
                tskIDLE_PRIORITY + 10, NULL);

    vTaskStartScheduler();
    taskEXIT_CRITICAL();
}
```



## 工程源码

![1575937372058](%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A.assets/1575937372058.png)

首先安装最下面的pack库,然后用MDK打开Project/MP3_Player.uvprojx工程编译之后下载运行即可(没有外接模块可能会无法正常运行).

## 心得体会

通过这学期的单片机实验,对于单片机内部结构的了解更加深入.对于工程的组织和编写更加熟练.在逻辑设计上有了一定的进步.通过使用示波器,万用表之类的工具进行硬件调试能力有所提升.
#  实验十一

## 一.实验目的

1.  了解四线电阻触摸屏的工作原理。
2.  学习触点坐标计算方法。
3.  了解触屏控制芯片 TSC2046 的控制方式。

## 二. 实验内容

调试四线电阻屏,令其能够识别触摸行为.

## 三.实验流程

```flow
st=>start: 开始
op1=>operation: 时钟初始化
op2=>operation: UART初始化
op3=>operation: EPI初始化
op4=>operation: 触摸控制初始化
op5=>operation: TFT LCD初始化
op6=>operation: 追踪显示触电
ed=>end: 结束
st->op1->op2->op3->op4->op5->op6->ed
```



## 四.实验代码

```c
  	     uint16_t ui32Loop = 0;
		uint32_t sum[2] = {0};
         SSIDataPut(SSI0_BASE, 0xd0);
		//绘制按键区域
		TFT_DrawRectangle(KEY4_CENTER_X-KEY_AREA,
                          KEY4_CENTER_Y-KEY_AREA,KEY_AREA*2,KEY_AREA*2,RED);
		TFT_DrawRectangle(KEY5_CENTER_X-KEY_AREA,
                          KEY5_CENTER_Y-KEY_AREA,KEY_AREA*2,KEY_AREA*2,RED);

		TFT_ShowName(110,210,1,WHITE);//关

		TFT_ShowName(110,320,0,WHITE);//开
		

		while(1)
		{
		if((TouchXData[NUM-1] <= 240) && 
           (TouchYData[NUM-1] <= 400) && 
           !GPIOPinRead(GPIO_PORTB_BASE,GPIO_PIN_0))
		{	
            	//识别按键
				uint8_t res = Button_Reconize(TouchXData[NUM-1], TouchYData[NUM-1]);
				switch(res)
				{
					case 1:
						xEventGroupSetBits(Command_Handle,KEY1_EVENT);
						break;
					case 2:
						xEventGroupSetBits(Command_Handle,KEY2_EVENT);
						break;
					default:
						break;
				}
				SysCtlDelay(7*SysClock/100);
		}
		
		for(ui32Loop = 0; ui32Loop < NUM-1; ui32Loop++)
		{
				SSIDataPut(SSI0_BASE, 0x90);
				SysCtlDelay(3);
				SSIDataGet(SSI0_BASE, &TouchXData[ui32Loop]);
				SysCtlDelay(3);
				SSIDataPut(SSI0_BASE, 0xd0);
				SysCtlDelay(3);
				SSIDataGet(SSI0_BASE, &TouchYData[ui32Loop]);
				SysCtlDelay(3);
		}
		for(int i=0;i<NUM-1;i++)
		{
			sum[0] += TouchXData[i];
			sum[1] += TouchYData[i];
			
		}
		TouchXData[NUM-1] = sum[0]/(NUM-1);
		TouchYData[NUM-1] = sum[1]/(NUM-1);
		sum[0]=0;
		sum[1]=0;
		TOUCH_PointAdjust(&TouchXData[NUM-1], &TouchYData[NUM-1]);
	}

static void Command_Control(void *pvParameters)
{
    //按键回调
	EventBits_t r_event;
	while(1)
	{
		r_event = xEventGroupWaitBits(Command_Handle,
                                KEY4_EVENT|KEY5_EVENT,
                                      pdTRUE,
                                      pdFALSE,
                                      portMAX_DELAY);
		switch(r_event)
		{
			case KEY4_EVENT: 
				LED_Close(1);
				LED_Close(2);
				LED_Close(3);
				LED_Close(4);
				LED_Close(5);
				LED_Close(6);
				LED_Close(7);
				LED_Close(8);
				BUZZER_Beep();			
				break;
			case KEY5_EVENT: 
				LED_Open(1);
				LED_Open(2);
				LED_Open(3);
				LED_Open(4);
				LED_Open(5);
				LED_Open(6);
				LED_Open(7);
				LED_Open(8);
				BUZZER_Beep();
				break;
			default:
				break;
		}
	}
}
```

## 五.实验效果

![1574730674431](C:%5CUsers%5CChenhui%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574730674431.png)

当按下相应按键,8个LED灯会同时亮起或熄灭.

## 思考题

采用了多次采样取平均的方式,进行滤波处理,效果不错

![1574735856830](%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80.assets/1574735856830.png)

# 实验十二

## 一.实验目的

1.  了解红外数据传输的通信原理。
2.  了解红外编码解码的原理
3.  掌握红外通信的编程

## 二. 实验内容

了解红外传输协议NEC.

## 三.实验流程

```flow
st=>start: 开始
op1=>operation: 初始化系统时钟
op2=>operation: 初始化相应的GPIO口和中断
op3=>operation: 有开启中断
op4=>operation: 指示错误
op5=>operation: 解码输出
cond1=>condition: 是否有低电平
cond2=>condition: 是否低电平9ms,高电平4.5ms
cond3=>condition: 解码是否成功
ed=>end: 结束
st->op1->op2->cond1
cond1(yes)->op3
cond1(no)->cond1
op3->cond2
cond2(yes)->cond3
cond2(no)->op4->cond1
cond3(yes)->op5->ed
cond3(no)->op4
```



## 四.实验代码

```c
//定时器中断
void Timer0BIntHandler(void)
{

    unsigned long Status;
		
   	Status = TimerIntStatus(TIMER0_BASE, true);

    if(Status == TIMER_TIMB_TIMEOUT)
    {
        tcount++;
    }
	TimerIntClear(TIMER0_BASE, Status);
}

//out脚中断
void 
GPION_IRQ(void)
{

	uint16_t ir_time;
	BaseType_t pxHigherPriorityTaskWoken;
  if(startflag)
  {
      ir_time = tcount; 
      if(tcount < 160 && tcount >= 50 ) // 接收到同步头
      {
          idx=0;  // 数组下标清零
      }

      irdata[idx] = tcount;  // 获取计数时间
      tcount = 0;            // 清零计数时间，以便下次统计
      idx++;                     // 接收到一个数据，索引加1

      if(idx==33)       // 如果接收到33个数据，包括32位数和以一个同步头
      {
          idx=0;
          tcount = 0;
          xSemaphoreGiveFromISR(InfraredReceive_Handle,&pxHigherPriorityTaskWoken);
      }
  }
  else   // 下降沿第一次触发
  {
      idx = 0;
      tcount = 0;
      startflag = 1;
  }


	
	GPIOIntClear(GPIO_PORTN_BASE,GPIO_INT_PIN_4);
	
}

//解码程序
uint8_t Ir_Server()
{
  uint8_t i,j,idx=1; //idx 从1 开始表示对同步头的时间不处理
  uint8_t temp;
  for(i=0; i<4; i++)
  {
      for(j=0; j<8; j++)
      {
          if(irdata[idx] >=8 && irdata[idx] < 15)   //表示 0
          {
              temp = 0;
          }
          else if(irdata[idx] >=18 && irdata[idx]<25) //表示 1
          {
              temp = 1;
          }
          remote_code[i] <<= 1;
          remote_code[i] |= temp;
          idx++;
      }
  }

  return remote_code[2];  // 该数组中记录的是控制码，每个按键不一样
}

```



## 五.实验效果

 ![1574731569125](C:%5CUsers%5CChenhui%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574731569125.png)


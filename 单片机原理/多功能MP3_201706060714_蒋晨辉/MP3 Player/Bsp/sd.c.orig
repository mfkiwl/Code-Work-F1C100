#include "sd.h"
#include "stdbool.h"

tContext g_sContext;;
tCmdLineEntry g_psCmdTable[] =
{
    { "help",   Cmd_help,      " : Display list of commands" },
    { "h",      Cmd_help,   "    : alias for help" },
    { "?",      Cmd_help,   "    : alias for help" },
    { "ls",     Cmd_ls,      "   : Display list of files" },
    { "chdir",  Cmd_cd,         ": Change directory" },
    { "cd",     Cmd_cd,      "   : alias for chdir" },
    { "pwd",    Cmd_pwd,      "  : Show current working directory" },
    { "cat",    Cmd_cat,      "  : Show contents of a text file" },
    { 0, 0, 0 }
};
tFresultString g_sFresultStrings[] =
{
    FRESULT_ENTRY(FR_OK),
    FRESULT_ENTRY(FR_DISK_ERR),
    FRESULT_ENTRY(FR_INT_ERR),
    FRESULT_ENTRY(FR_NOT_READY),
    FRESULT_ENTRY(FR_NO_FILE),
    FRESULT_ENTRY(FR_NO_PATH),
    FRESULT_ENTRY(FR_INVALID_NAME),
    FRESULT_ENTRY(FR_DENIED),
    FRESULT_ENTRY(FR_EXIST),
    FRESULT_ENTRY(FR_INVALID_OBJECT),
    FRESULT_ENTRY(FR_WRITE_PROTECTED),
    FRESULT_ENTRY(FR_INVALID_DRIVE),
    FRESULT_ENTRY(FR_NOT_ENABLED),
    FRESULT_ENTRY(FR_NO_FILESYSTEM),
    FRESULT_ENTRY(FR_MKFS_ABORTED),
    FRESULT_ENTRY(FR_TIMEOUT),
    FRESULT_ENTRY(FR_LOCKED),
    FRESULT_ENTRY(FR_NOT_ENOUGH_CORE),
    FRESULT_ENTRY(FR_TOO_MANY_OPEN_FILES),
    FRESULT_ENTRY(FR_INVALID_PARAMETER)
};
const char *
StringFromFresult(FRESULT fresult)
{
    unsigned int uIdx;

    //
    // Enter a loop to search the error code table for a matching error code.
    //
    for(uIdx = 0; uIdx < NUM_FRESULT_CODES; uIdx++)
    {
        //
        // If a match is found, then return the string name of the error code.
        //
        if(g_sFresultStrings[uIdx].fresult == fresult)
        {
            return(g_sFresultStrings[uIdx].pcResultStr);
        }
    }

    //
    // At this point no matching code was found, so return a string indicating
    // an unknown error.
    //
    return("UNKNOWN ERROR CODE");
}


int
Cmd_ls(int argc, char *argv[])
{
    unsigned long ulTotalSize;
    unsigned long ulFileCount;
    unsigned long ulDirCount;
    FRESULT fresult;
    FATFS *pFatFs;

    //
    // Open the current directory for access.
    //
    fresult = f_opendir(&g_sDirObject, g_cCwdBuf);

    //
    // Check for error and return if there is a problem.
    //
    if(fresult != FR_OK)
    {
        return(fresult);
    }

    ulTotalSize = 0;
    ulFileCount = 0;
    ulDirCount = 0;

    //
    // Give an extra blank line before the listing.
    //
    UARTprintf("\n");

    //
    // Enter loop to enumerate through all directory entries.
    //
    for(;;)
    {
        //
        // Read an entry from the directory.
        //
        fresult = f_readdir(&g_sDirObject, &g_sFileInfo);

        //
        // Check for error and return if there is a problem.
        //
        if(fresult != FR_OK)
        {
            return(fresult);
        }

        //
        // If the file name is blank, then this is the end of the listing.
        //
        if(!g_sFileInfo.fname[0])
        {
            break;
        }

        //
        // If the attribue is directory, then increment the directory count.
        //
        if(g_sFileInfo.fattrib & AM_DIR)
        {
            ulDirCount++;
        }

        //
        // Otherwise, it is a file.  Increment the file count, and add in the
        // file size to the total.
        //
        else
        {
            ulFileCount++;
            ulTotalSize += g_sFileInfo.fsize;
        }

        //
        // Print the entry information on a single line with formatting to show
        // the attributes, date, time, size, and name.
        //
        UARTprintf("%c%c%c%c%c %u/%02u/%02u %02u:%02u %9u  %s\n",
                   (g_sFileInfo.fattrib & AM_DIR) ? 'D' : '-',
                   (g_sFileInfo.fattrib & AM_RDO) ? 'R' : '-',
                   (g_sFileInfo.fattrib & AM_HID) ? 'H' : '-',
                   (g_sFileInfo.fattrib & AM_SYS) ? 'S' : '-',
                   (g_sFileInfo.fattrib & AM_ARC) ? 'A' : '-',
                   (g_sFileInfo.fdate >> 9) + 1980,
                   (g_sFileInfo.fdate >> 5) & 15,
                   g_sFileInfo.fdate & 31,
                   (g_sFileInfo.ftime >> 11),
                   (g_sFileInfo.ftime >> 5) & 63,
                   g_sFileInfo.fsize,
                   g_sFileInfo.fname);
    }

    //
    // Print summary lines showing the file, dir, and size totals.
    //
    UARTprintf("\n%4u File(s),%10u bytes total\n%4u Dir(s)",
               ulFileCount, ulTotalSize, ulDirCount);

    //
    // Get the free space.
    //
    fresult = f_getfree("/", &ulTotalSize, &pFatFs);

    //
    // Check for error and return if there is a problem.
    //
    if(fresult != FR_OK)
    {
        return(fresult);
    }

    //
    // Display the amount of free space that was calculated.
    //
    UARTprintf(", %10uK bytes free\n", ulTotalSize * pFatFs->csize / 2);

    //
    // Made it to here, return with no errors.
    //
    return(0);
}

//*****************************************************************************
//
// This function implements the "cd" command.  It takes an argument that
// specifies the directory to make the current working directory.  Path
// separators must use a forward slash "/".  The argument to cd can be one of
// the following:
//
// * root ("/")
// * a fully specified path ("/my/path/to/mydir")
// * a single directory name that is in the current directory ("mydir")
// * parent directory ("..")
//
// It does not understand relative paths, so dont try something like this:
// ("../my/new/path")
//
// Once the new directory is specified, it attempts to open the directory to
// make sure it exists.  If the new path is opened successfully, then the
// current working directory (cwd) is changed to the new path.
//
//*****************************************************************************
int
Cmd_cd(int argc, char *argv[])
{
    unsigned int uIdx;
    FRESULT fresult;

    //
    // Copy the current working path into a temporary buffer so it can be
    // manipulated.
    //
    strcpy(g_cTmpBuf, g_cCwdBuf);

    //
    // If the first character is /, then this is a fully specified path, and it
    // should just be used as-is.
    //
    if(argv[1][0] == '/')
    {
        //
        // Make sure the new path is not bigger than the cwd buffer.
        //
        if(strlen(argv[1]) + 1 > sizeof(g_cCwdBuf))
        {
            UARTprintf("Resulting path name is too long\n");
            return(0);
        }

        //
        // If the new path name (in argv[1])  is not too long, then copy it
        // into the temporary buffer so it can be checked.
        //
        else
        {
            strncpy(g_cTmpBuf, argv[1], sizeof(g_cTmpBuf));
        }
    }

    //
    // If the argument is .. then attempt to remove the lowest level on the
    // CWD.
    //
    else if(!strcmp(argv[1], ".."))
    {
        //
        // Get the index to the last character in the current path.
        //
        uIdx = strlen(g_cTmpBuf) - 1;

        //
        // Back up from the end of the path name until a separator (/) is
        // found, or until we bump up to the start of the path.
        //
        while((g_cTmpBuf[uIdx] != '/') && (uIdx > 1))
        {
            //
            // Back up one character.
            //
            uIdx--;
        }

        //
        // Now we are either at the lowest level separator in the current path,
        // or at the beginning of the string (root).  So set the new end of
        // string here, effectively removing that last part of the path.
        //
        g_cTmpBuf[uIdx] = 0;
    }

    //
    // Otherwise this is just a normal path name from the current directory,
    // and it needs to be appended to the current path.
    //
    else
    {
        //
        // Test to make sure that when the new additional path is added on to
        // the current path, there is room in the buffer for the full new path.
        // It needs to include a new separator, and a trailing null character.
        //
        if(strlen(g_cTmpBuf) + strlen(argv[1]) + 1 + 1 > sizeof(g_cCwdBuf))
        {
            UARTprintf("Resulting path name is too long\n");
            return(0);
        }

        //
        // The new path is okay, so add the separator and then append the new
        // directory to the path.
        //
        else
        {
            //
            // If not already at the root level, then append a /
            //
            if(strcmp(g_cTmpBuf, "/"))
            {
                strcat(g_cTmpBuf, "/");
            }

            //
            // Append the new directory to the path.
            //
            strcat(g_cTmpBuf, argv[1]);
        }
    }

    //
    // At this point, a candidate new directory path is in chTmpBuf.  Try to
    // open it to make sure it is valid.
    //
    fresult = f_opendir(&g_sDirObject, g_cTmpBuf);

    //
    // If it can't be opened, then it is a bad path.  Inform the user and
    // return.
    //
    if(fresult != FR_OK)
    {
        UARTprintf("cd: %s\n", g_cTmpBuf);
        return(fresult);
    }

    //
    // Otherwise, it is a valid new path, so copy it into the CWD.
    //
    else
    {
        strncpy(g_cCwdBuf, g_cTmpBuf, sizeof(g_cCwdBuf));
    }

    //
    // Return success.
    //
    return(0);
}

//*****************************************************************************
//
// This function implements the "pwd" command.  It simply prints the current
// working directory.
//
//*****************************************************************************
int
Cmd_pwd(int argc, char *argv[])
{
    //
    // Print the CWD to the console.
    //
    UARTprintf("%s\n", g_cCwdBuf);

    //
    // Return success.
    //
    return(0);
}

//*****************************************************************************
//
// This function implements the "cat" command.  It reads the contents of a file
// and prints it to the console.  This should only be used on text files.  If
// it is used on a binary file, then a bunch of garbage is likely to printed on
// the console.
//
//*****************************************************************************
int
Cmd_cat(int argc, char *argv[])
{
    FRESULT fresult;
    unsigned int usBytesRead;

    //
    // First, check to make sure that the current path (CWD), plus the file
    // name, plus a separator and trailing null, will all fit in the temporary
    // buffer that will be used to hold the file name.  The file name must be
    // fully specified, with path, to FatFs.
    //
    if(strlen(g_cCwdBuf) + strlen(argv[1]) + 1 + 1 > sizeof(g_cTmpBuf))
    {
        UARTprintf("Resulting path name is too long\n");
        return(0);
    }

    //
    // Copy the current path to the temporary buffer so it can be manipulated.
    //
    strcpy(g_cTmpBuf, g_cCwdBuf);

    //
    // If not already at the root level, then append a separator.
    //
    if(strcmp("/", g_cCwdBuf))
    {
        strcat(g_cTmpBuf, "/");
    }

    //
    // Now finally, append the file name to result in a fully specified file.
    //
    strcat(g_cTmpBuf, argv[1]);

    //
    // Open the file for reading.
    //
    fresult = f_open(&g_sFileObject, g_cTmpBuf, FA_READ);

    //
    // If there was some problem opening the file, then return an error.
    //
    if(fresult != FR_OK)
    {
        return(fresult);
    }

    //
    // Enter a loop to repeatedly read data from the file and display it, until
    // the end of the file is reached.
    //
    do
    {
        //
        // Read a block of data from the file.  Read as much as can fit in the
        // temporary buffer, including a space for the trailing null.
        //
        fresult = f_read(&g_sFileObject, g_cTmpBuf, sizeof(g_cTmpBuf) - 1,
                         &usBytesRead);

        //
        // If there was an error reading, then print a newline and return the
        // error to the user.
        //
        if(fresult != FR_OK)
        {
            UARTprintf("\n");
            return(fresult);
        }

        //
        // Null terminate the last block that was read to make it a null
        // terminated string that can be used with printf.
        //
        g_cTmpBuf[usBytesRead] = 0;

        //
        // Print the last chunk of the file that was received.
        //
        UARTprintf("%s", g_cTmpBuf);
    }
    while(usBytesRead == sizeof(g_cTmpBuf) - 1);

    //
    // Return success.
    //
    return(0);
}

//*****************************************************************************
//
// This function implements the "help" command.  It prints a simple list of the
// available commands with a brief description.
//
//*****************************************************************************
int
Cmd_help(int argc, char *argv[])
{
    tCmdLineEntry *pEntry;

    //
    // Print some header text.
    //
    UARTprintf("\nAvailable commands\n");
    UARTprintf("------------------\n");

    //
    // Point at the beginning of the command table.
    //
    pEntry = &g_psCmdTable[0];

    //
    // Enter a loop to read each entry from the command table.  The end of the
    // table has been reached when the command name is NULL.
    //
    while(pEntry->pcCmd)
    {
        //
        // Print the command name and the brief description.
        //
        UARTprintf("%s%s\n", pEntry->pcCmd, pEntry->pcHelp);

        //
        // Advance to the next entry in the table.
        //
        pEntry++;
    }

    //
    // Return success.
    //
    return(0);
}

//*****************************************************************************
//
// This is the table that holds the command names, implementing functions, and
// brief description.
//
//*****************************************************************************


void
SysTickIntHandler(void)
{
    //
    // Call the FatFs tick timer.
    //
    disk_timerproc();
}


void SD_Init()
{
//	FPUEnable();
//  FPULazyStackingEnable();
//	ROM_SysTickPeriodSet(10*SysCtlClockGet()/ 3000);
//	ROM_IntMasterEnable();
//	SysTickIntRegister(SysTickIntHandler);
//	ROM_SysTickIntEnable();
//	ROM_SysTickEnable();

}
int SD_Test()
{
    int nStatus;
    FRESULT fresult;



    UARTprintf("\n\nSD Card Example Program\n");
    UARTprintf("Type \'help\' for help.\n");

    fresult = f_mount(0, &g_sFatFs);
    if(fresult != FR_OK)
    {
        UARTprintf("f_mount error: %s\n", StringFromFresult(fresult));
        return(1);
    }

    while(1)
    {
        //
        // Print a prompt to the console.  Show the CWD.
        //
        UARTprintf("\n%s> ", g_cCwdBuf);

        //
        // Get a line of text from the user.
        //
        UARTgets(g_cCmdBuf, sizeof(g_cCmdBuf));

        //
        // Pass the line from the user to the command processor.  It will be
        // parsed and valid commands executed.
        //
        nStatus = CmdLineProcess(g_cCmdBuf);

        //
        // Handle the case of bad command.
        //
        if(nStatus == CMDLINE_BAD_CMD)
        {
            UARTprintf("Bad command!\n");
        }

        //
        // Handle the case of too many arguments.
        //
        else if(nStatus == CMDLINE_TOO_MANY_ARGS)
        {
            UARTprintf("Too many arguments for command processor!\n");
        }

        //
        // Otherwise the command was executed.  Print the error code if one was
        // returned.
        //
        else if(nStatus != 0)
        {
            UARTprintf("Command returned error code %s\n",
                       StringFromFresult((FRESULT)nStatus));
        }
    }
}

//*  函数名称： NameCompare
//*  功 能：字符串比较 比较 0X2E前的字符 ( 文件名比较 )
//*  输入参数： str1,str2
//*  输出参数： TRUE 两字符串相同 FALSE  两字符串不同
//*  编 写：Bunagi
//*  修 改：2010/9/4
//*******************************************************************
//****************
bool NameCompare(uint8_t *str1, uint8_t *str2)
{
    uint8_t i = 13;
    uint8_t flag;
    while(--i)
    {
        if(str1[i] == 0x2e) flag = i;
    }
    for(i = 0; i < flag + 3; i++)
    {
        if(str1[i] != str2[i]) return FALSE;
    }
    return TRUE;
}

//*******************************************************************
//*  函数名称： BMPInfoLoad
//*  功 能：读 SD卡里 BMP文件的头 512字节数据，并填充进 BMP信息数据结构里
//*  输入参数： bfinfo
//* binfo
//* Buf
//*  输出参数：无
//*  编 写：Bunagi
//*  修 改：2010/9/4
//*******************************************************************
void BMPInfoLoad(BMPFILINFO *bfinfo, BMPINFO *binfo, uint8_t *Buf)
{
//  填充 BMPFIL信息
    bfinfo->wBFIType = (Buf[0] << 8) + Buf[1];
    bfinfo->dwBFISize = (Buf[5] << 24) + (Buf[4] << 16) + (Buf[3] << 8) + Buf[2];
    bfinfo->dwBFIReserved = 0x00;
    bfinfo->dwBFIStartAdd = (Buf[13] << 24) + (Buf[12] << 16) + (Buf[11] << 8) + Buf[10];
// 填充 BMP信息
    binfo->dwBISize = (Buf[17] << 24) + (Buf[16] << 16) + (Buf[15] << 8) +
                      Buf[14];
    binfo->dwBIWidth = (Buf[21] << 24) + (Buf[20] << 16) + (Buf[19] << 8) +
                       Buf[18];
    binfo->dwBIHeight = (Buf[25] << 24) + (Buf[24] << 16) + (Buf[23] << 8) +
                        Buf[22];
    binfo->wBIPlanes = 0x01;
    binfo->wBIBitCount = (Buf[29] << 8) + Buf[28];
    binfo->dwBICompression = (Buf[33] << 24)  + (Buf[32] << 16)  + (Buf[31] << 8)  +
                             Buf[30];
    binfo->dwBISizeImage = (Buf[37] << 24) + (Buf[36] << 16) + (Buf[35] << 8) +
                           Buf[34];
    binfo->dwBIXPelsPerMeter  = (Buf[41] << 24)  + (Buf[40] << 16)  + (Buf[39] << 8)
                                + Buf[38];
    binfo->dwBIYPelsPerMeter  = (Buf[45] << 24)  + (Buf[44] << 16)  + (Buf[43] << 8)
                                + Buf[42];
    binfo->dwBIClrUsed = (Buf[49] << 24) + (Buf[48] << 16) + (Buf[47] << 8) +
                         Buf[46];
    binfo->dwBIClrImportant = (Buf[53] << 24) + (Buf[52] << 16) + (Buf[51] << 8)
                              + Buf[50];
}

//*******************************************************************

//*  函数名称： BMPDisp
//*  功 能：在指定坐标点位置显示图片 ( 图片大小依据 LCD屏开始及结束坐标确定
//*  输入参数：
//*  输出参数：
//*  编 写：Bunagi
//*  修 改：2010/9/4
//*******************************************************************

bool BMPDisp(FIL *fil,DIR  *dir,FILINFO  *fno,u8 *FilSearch,u8  *Buf,LOC_X tft_end_x,LOC_Y tft_end_y)
{
u8 color_byte,rgb;
int tft_x,tft_y;
u16 count,color,tft_start_x,tft_start_y;
UINT len;
BMPFILINFO bfinfo;
	BMPINFO binfo;
FRESULT res;
tft_x = tft_end_x;
tft_y = tft_end_y;
rgb = 0;
res = f_opendir(dir,"");
// 查找指定文件名的文件
while(1)
{
res =f_readdir(dir,fno);
if(res != FR_OK) return FALSE;
if(NameCompare(fno->fname,FilSearch)) break;
else if(fno->fname[0] == 0) return FALSE;
}
res = f_open(fil,fno->fname,FA_OPEN_EXISTING | FA_READ);
if(res != FR_OK) return FALSE;
res = f_read(fil,Buf,BMPBufSize,&len);
if(res != FR_OK) return FALSE;
BMPInfoLoad(&bfinfo,&binfo,Buf);
tft_start_x = tft_end_x - (u16)(binfo.dwBIWidth-1);
tft_start_y = tft_end_y - (u16)(binfo.dwBIHeight-1);
rgb = 0;
count = bfinfo.dwBFIStartAdd; //  当前象素数据地址指针
color_byte = binfo.wBIBitCount >> 3; // binfo.wBIBitCount / 8  判断是几位的位图
do
{
while(count < BMPBufSize)
{
// 处理 24 位位图
if(color_byte == 3)
{
switch(rgb)
{
case 0: //  兰色象素数据转换成R5G6B5格式
{
color = Buf[count] >> 3;
rgb++;
break;
}
case 1: //  绿色象素数据转换成
R5G6B5格式
{
color |= (Buf[count] >> 2) << 5;
rgb++;
break;
}
case 2: //  红色象素数据转换成
R5G6B5格式
{
color |= (Buf[count] >> 3) << 11;
rgb++;
break;
}
default: break;
}
if(rgb == color_byte) //  象素转换完成
{
TFTPoint(tft_x,tft_y,color);
color = 0;
rgb = 0;
if(--tft_x < tft_start_x)
{
tft_x = tft_end_x;
if(--tft_y < tft_start_y) return TRUE;
//  处理每行象素对齐
if(((binfo.dwBIWidth*3)%4) != 0) count +=4 -
((binfo.dwBIWidth*3)%4);
}
}
count ++;
}
else
{
//  添加处理其它比如 16 位图的程序
}
}
	//  读下一个扇区数据
if(f_read(fil,Buf,BMPBufSize,&len)) return FALSE;
count = 0;
}while(!res && len);
return TRUE;
}
static void SD_ShowBMP(void)
{
    FATFS fs;
    DIR dir;
    FIL fil;
    FILINFO fno;
    FRESULT res;
    char Buf[512];
    uint8_t i;
    char FilSearchCount[10][13]; //  文件名检索存放

    f_mount(0, &fs);
}
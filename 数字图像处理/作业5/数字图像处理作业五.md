# 数字图像处理作业五

#### 7.5 设信源$X=\{a,b,c,d\}$,且$p(a)=\frac{1}{8},p(b)=\frac{5}{8},p(c)=\frac{1}{8},p(d)=\frac{1}{8}$,计算各符号的自信息量和信源熵.

$I(a)=I(c)=I(d)=log_2(\frac{1}{p(a)})=3$

$I(b)=log_2(\frac{1}{p(b)})=0.678$

$H(X)=\frac{1}{8}*3*3+\frac{5}{8}*0.678=1.549$

#### 7.7 根据图7.2所示的Huffman树,下面是某图像的一段Huffman编码.请将其解码写出来
​						$11100100100000110000001101110000000111000000110110$

$P(001)=\frac{5}{17},P(000)=\frac{4}{17},P(110)=\frac{2}{17},P(011)=\frac{2}{17},P(100)=\frac{2}{17},P(111)=\frac{1}{17},P(101)=\frac{1}{17}$



![无标题](C:\Users\Chenhui\Pictures\无标题.png)

| 信源符号 | 出现概率 | 码字 | 码长 |
| :------: | :------: | :--: | :--: |
|   001    |   5/17   |  11  |  2   |
|   000    |   4/17   |  10  |  2   |
|   110    |   2/17   | 000  |  3   |
|   011    |   2/17   | 001  |  3   |
|   100    |   2/17   | 011  |  3   |
|   111    |   1/17   | 0101 |  4   |
|   101    |   1/17   | 0100 |  4   |

####      编程实现DCT编码实例中的近似JPEG编解码过程，并用一张图像做验证。  

```matlab
%jpegencode函数用来压缩图像用一种近似的JPEG方法
function res=jpegencode(x,quality)
    %x 为输入图像
    %quality决定了截去的系数和压缩比
    error(nargchk(1,2,nargin));           %检查输入参数
    if nargin<2
        quality=1;                        %缺省的quality=1
    end
    x=double(x)-128;                      %像素层次移动-128
    [xm,xn]=size(x);                      %得到图像的尺
    t=dctmtx(8);                          %得到8*8DCT变换矩阵
    %将图像分割成8*8子图?,进行DCT变换,然后进行量化
    y=blkproc(x,[8 8],'dct2(x)') %            'P1*x*P2',t,t');
    m=[16 11 10 16 24 40 51 61            %JEPG标准化矩
        12 12 14 19 26 58 60 55
        14 13 16 24 40 57 69 56
        14 17 22 29 51 87 80 62
        18 22 37 56 68 109 103 77
        24 35 55 64 81 104 113 92
        49 64 78 87 103 121 120 101
        72 92 95 98 112 100 103 99]*quality;
     %用m标准化阵列对变换阵列进行量化
    yy=blkproc(y,[8 8],'round(x./P1)',m);  
    y=im2col(yy,[8 8],'distinct');               %将图像块排列成向量
    xb=size(y,2);                                %得到列数,也就子图像个数
    order=[1 9 2 3 10 17 25 18 11 4 5 12 19 26 33 ... %变换系数排列次序
        41 34 27 20 13 6 7 14 21 28 35 42 49 57 50 ...
        43 36 29 22 15 8 16 23 30 37 44 51 58 59 52 ... 
       45 38 31 24 32 39 46 53 60 61 54 47 40 48 55 62 63 56 64];
    %用Z形模板对变换系数重新排列
    y=y(order,:);
    eob=max(x(:))+1;                               
    num=numel(y)+size(y,2);
    r=zeros(num,1);
    count=0;
    %将非零元素重新排列
    for j=1:xb                               
        i=max(find(y(:,j)));                 %找最后一个非零元素
        if isempty(i)                        %没有非零元素
            i=0;
        end
        p=count+1;
        q=p+i;
        r(p:q)=[y(1:i,j);eob];               %截去0 并加上结束符号
        count=count+i+1;              
    end
    r((count+1):end)=[];                      %删除没有用的部分
    
    r=r+128;               
    %保存编码信息
    res.size=uint16([xm,xn]);
    res.numblocks=uint16(xb);
    res.quality=uint16(quality*100);
    %对r进行huffman编码
    [res.huffman res.info]=huffencode(uint8(r));
    
    
    %jpegdecode函数jpegedcode的解码程序
function x=jpegdecode(y)
    error(nargchk(1,1,nargin));           %检查输入参数
    m=[16 11 10 16 24 40 51 61            %JEPG标准化矩阵
        12 12 14 19 26 58 60 55
        14 13 16 24 40 57 69 56
        14 17 22 29 51 87 80 62
        18 22 37 56 68 109 103 77
        24 35 55 64 81 104 113 92
        49 64 78 87 103 121 120 101
        72 92 95 98 112 100 103 99];
    order=[1 9 2 3 10 17 25 18 11 4 5 12 19 26 33 ... %变换系数排列次序
        41 34 27 20 13 6 7 14 21 28 35 42 49 57 50 ...
        43 36 29 22 15 8 16 23 30 37 44 51 58 59 52 ... 
       45 38 31 24 32 39 46 53 60 61 54 47 40 48 55 62 63 56 64];
       rev=order;                                    %计算逆序
    for k=1:length(order)
        rev(k)=find(order==k);
    end
    %ff=max(rev(:))+1;
    m=double(y.quality)/100*m;
    xb=double(y.numblocks);             %得到图像块数
    sz=double(y.size);
    xn=sz(1);                          %得到行数
    xm=sz(2);                          %得到列数
    x=huffdecode(y.huffman,y.info);    %huffman解码
    x=double(x)-128;
    eob=max(x(:));                    %得到块结束符
    z=zeros(64,xb);k=1;
    for j=1:xb
        for i=1:64
            if x(k)==eob
                k=k+1;break;
            else
                z(i,j)=x(k);
                k=k+1;
            end
        end
    end
    z=z(rev,:);                      %恢复次序
    x=col2im(z,[8 8],[xm xn],'distinct');%重新排列成图像块
    x=blkproc(x,[8 8],'x.*P1',m);       %反标准化 
    t=dctmtx(8);                        
    x=blkproc(x,[8 8], 'P1*x*P2',t',t);  %DCT反变换
    x=uint8(x+128);                      %进行位移
  
 %测试函数
 function DCT_Test
    clear all
    x = imread('lena.bmp');
    figure(1);
    subplot(121);
    imshow(x);
    y = jpegencode(x, 5);
    X = jpegdecode(y);
    subplot(122);
    imshow(X);

    e = double(x) - double(X);
    [m, n] = size(e);
    erms = sqrt(sum(e(:).^2) / (m * n))
    cr = imageratio(x, y)

```

* 运行结果

  ![1573448177153](%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A%E4%BA%94.assets/1573448177153.png)

![1573448192539](%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A%E4%BA%94.assets/1573448192539.png)


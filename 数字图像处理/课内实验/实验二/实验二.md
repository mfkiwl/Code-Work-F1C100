# 实验二	图像几何变换实验

## 实验目的

1. 学习几种常见的图像几何变换，并通过实验体会几何变换的效果；
2. 掌握图像平移、剪切、缩放、旋转、镜像等几何变换的算法原理及编程实现； 
3. 掌握 matlab 编程环境中基本的图像处理函数。

## 实验内容

1. 启动 MATLAB 程序，对图像文件分别进行平移、垂直镜像变换、水平镜像变换、缩放和 旋转操作。
2. 运行图像处理程序，并保存处理结果图像。

## 源代码

```matlab
%平移
I=imread( 'lena.jpg' );
subplot(121),imshow(I);
title( 'before' );
I=double(I);
M=zeros(size(I));
 
N=size(I);
x=50;
y=50;
M(x+1:N(1),y+1:N(2))=I(1:N(1)-x,1:N(2)-y);
subplot(122),imshow(uint8(M));
title( 'after' );

%水平垂直镜像
I=imread( 'lena.jpg' );
subplot(131),imshow(I);
title( 'before' );
I=double(I);
A=zeros(size(I));
B=zeros(size(I));
M=size(I);
A(1:M(1),1:M(2))=I(M(1):-1:1,1:M(2));
B(1:M(1),1:M(2))=I(1:M(1),M(2):-1:1);
subplot(132),imshow(uint8(A));
title( ' 竖直 ' );
subplot(133),imshow(uint8(B));
title( ' 水平 ' );

%缩放
I=imread( 'lena.jpg' );
subplot(131),imshow(I);
title( 'before' );
I=double(I);
A=zeros(size(I));
B=zeros(size(I));
[m,n]=size(I);
x=1.8;
y=1.8;
x2=0.85;
y2=0.85;
for  i=1:m
      for  j=1:n
          i1=round(i*x);
          j1=round(j*y);
          i2=round(i*x2);
          j2=round(j*y2);
          if (j1>=0)&&(i1>=0)&&(i1<=m)&&(j1<=n)
        	 A(i,j)=I(i1,j1);
          end
          if (j2>=0)&&(i2>=0)&&(i2<=m)&&(j2<=n)
         	B(i,j)=I(i2,j2);
          end
      end
end
subplot(132),imshow(uint8(A));
title( 'small' );
subplot(133),imshow(uint8(B));
title( 'big' );

%旋转
jiao=50; 
M=imread( 'lena.jpg' ); 
imshow(M); 
[h w]=size(M);
 
theta=jiao/180*pi;
rot=[cos(theta) -sin(theta) 0;sin(theta) cos(theta) 0;0 0 1];  % 建立变换矩阵
pix1=[1 1 1]*rot;  % 变后左上
pix2=[1 w 1]*rot;  % 变后右上
pix3=[h 1 1]*rot;  % 变后左下
pix4=[h w 1]*rot;  % 变后右下
 
height=round(max([abs(pix1(1)-pix4(1))+0.5 abs(pix2(1)-pix3(1))+0.5]));  % 新宽
width=round(max([abs(pix1(2)-pix4(2))+0.5 abs(pix2(2)-pix3(2))+0.5]));  % 新高
N=zeros(height,width);
 
chao_y=abs(min([pix1(1) pix2(1) pix3(1) pix4(1)]));  %y 负轴超量
chao_x=abs(min([pix1(2) pix2(2) pix3(2) pix4(2)]));  %x 负轴超量
 
for  i=1-chao_y:height-chao_y
      for  j=1-chao_x:width-chao_x
         pix=[i j 1]/rot;  % 用变换后图像的点的坐标去寻找原图像点的坐标，  

         float_Y=pix(1)-floor(pix(1));  % 向下舍入
         float_X=pix(2)-floor(pix(2)); 

         if  pix(1)>=1 && pix(2)>=1 && pix(1) <= h && pix(2) <= w 

         pix_up_left=[floor(pix(1)) floor(pix(2))];  % 四个相邻的点
         pix_up_right=[floor(pix(1)) ceil(pix(2))];
         pix_down_left=[ceil(pix(1)) floor(pix(2))];
         pix_down_right=[ceil(pix(1)) ceil(pix(2))]; 

         value_up_left=(1-float_X)*(1-float_Y);  % 周围四个点权重
         value_up_right=float_X*(1-float_Y);
         value_down_left=(1-float_X)*float_Y;
         value_down_right=float_X*float_Y;

         N(i+chao_y,j+chao_x)=value_up_left*M(pix_up_left(1),pix_up_left(2))+  ...
         value_up_right*M(pix_up_right(1),pix_up_right(2))+  ...
         value_down_left*M(pix_down_left(1),pix_down_left(2))+  ...
         value_down_right*M(pix_down_right(1),pix_down_right(2));
         end  

      end
end
 
figure,imshow(uint8(N))

```

## 实验现象

![1572749599669](%E5%AE%9E%E9%AA%8C%E4%BA%8C.assets/1572749599669.png)

![1572749770692](%E5%AE%9E%E9%AA%8C%E4%BA%8C.assets/1572749770692.png)

![1572749917945](%E5%AE%9E%E9%AA%8C%E4%BA%8C.assets/1572749917945.png)

![1572750076687](%E5%AE%9E%E9%AA%8C%E4%BA%8C.assets/1572750076687.png)